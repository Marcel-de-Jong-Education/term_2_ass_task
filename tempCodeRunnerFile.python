import numpy as np
import matplotlib.pyplot as plt

# Constants
G = 1.0
dt = 0.05
steps = 1000

# Target body
target_pos = np.array([0.0, 0.0])
target_vel = np.array([0.0, 0.0])
target_mass = 50.0

# Orbiting body
orbit_pos = np.array([5.0, 0.0])
orbit_mass = 1.0

def corrected_gradient_orbit_velocity(target_pos, target_vel, target_mass, orbit_pos, orbit_mass, clockwise=True):
    dx = target_pos[0] - orbit_pos[0]
    dy = target_pos[1] - orbit_pos[1]
    distance = np.sqrt(dx**2 + dy**2)

    if dy == 0:
        tangential_gradient = 2**31  # Large number simulating vertical
    else:
        tangential_gradient = -dx / dy

    orbital_speed = np.sqrt(G * (target_mass + orbit_mass) / distance)

    horizontal_component = np.sqrt( (orbital_speed**2) / (1 + tangential_gradient**2) ) + 0.0001
    vertical_component = tangential_gradient * horizontal_component

    if not clockwise:
        horizontal_component *= -1
        vertical_component *= -1

    return target_vel + np.array([horizontal_component, vertical_component])

def circular_orbit_velocity(target_pos, target_vel, target_mass, orbit_pos):
    offset = orbit_pos - target_pos
    r = np.linalg.norm(offset)
    unit_offset = offset / r
    tangent = np.array([-unit_offset[1], unit_offset[0]])  # Perpendicular
    speed = np.sqrt(G * target_mass / r)
    return target_vel + tangent * speed

def simulate_orbit(initial_pos, initial_vel, mass, target_pos, target_mass, steps, dt):
    pos = initial_pos.copy()
    vel = initial_vel.copy()
    trajectory = []

    for _ in range(steps):
        dx = target_pos[0] - pos[0]
        dy = target_pos[1] - pos[1]
        r = np.sqrt(dx**2 + dy**2)
        force = G * target_mass * mass / (r**2)
        acc = force / mass
        ax = acc * dx / r
        ay = acc * dy / r

        vel[0] += ax * dt
        vel[1] += ay * dt
        pos[0] += vel[0] * dt
        pos[1] += vel[1] * dt

        trajectory.append(pos.copy())

    return np.array(trajectory)

# Simulate both orbits
gradient_velocity = corrected_gradient_orbit_velocity(target_pos, target_vel, target_mass, orbit_pos, orbit_mass)
circular_velocity = circular_orbit_velocity(target_pos, target_vel, target_mass, orbit_pos)

gradient_orbit = simulate_orbit(orbit_pos, gradient_velocity, orbit_mass, target_pos, target_mass, steps, dt)
circular_orbit = simulate_orbit(orbit_pos, circular_velocity, orbit_mass, target_pos, target_mass, steps, dt)

# Plot results
plt.figure(figsize=(12, 6))

plt.subplot(1, 2, 1)
plt.plot(gradient_orbit[:, 0], gradient_orbit[:, 1], label="Orbit path")
plt.scatter(*target_pos, color='orange', label="Target")
plt.title("Corrected Gradient-Based Orbit")
plt.axis("equal")
plt.grid(True)
plt.legend()

plt.subplot(1, 2, 2)
plt.plot(circular_orbit[:, 0], circular_orbit[:, 1], label="Orbit path")
plt.scatter(*target_pos, color='orange', label="Target")
plt.title("Standard Circular Orbit")
plt.axis("equal")
plt.grid(True)
plt.legend()

plt.tight_layout()
plt.show()
